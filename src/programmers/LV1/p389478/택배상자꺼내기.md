https://school.programmers.co.kr/learn/courses/30/lessons/389478

### 문제 풀이 날짜
2025-11-10

### 문제 분석 요약
- 한줄에 w개씩 n개의 택배상자가 있다
- 꺼내려고 하는 상자 번호가 주어질때 몇개의 택배 상자를 꺼내야하는지 구하는 문제

### 제약조건
- - 2 ≤ `n` ≤ 100
- 1 ≤ `w` ≤ 10
- 1 ≤ `num` ≤ `n`
### 알고리즘 설계

문제의 핵심
- 구하려고 있는 숫자와 같은 열에 있는 개수 세기
- 상자 쌓는 방식이 홀수층은 왼쪽 -> 오른쪽, 짝수층은 오른쪽 -> 왼쪽으로 쌓인다
#### 입력
- 택배 상자 개수 n
- 가로로 놓는 상자 개수 w
- 택배 상자 번호 나타내는 정수 num
#### 연산
- num이 속한 층 계산
    - `layer = (num - 1) / w + 1` : num 상자가 몇 층에 있는지
    - `layerStart = (layer - 1) * w + 1` : 해당 층의 시작 상자 번호
- 층 내에서의 위치 계산 (posInLayer)
    - 홀수 층 (왼→오): `posInLayer = num - layerStart`
    - 짝수 층 (오→왼): `posInLayer = layerStart + w - 1 - num`
    - 이 값은 0부터 시작하는 인덱스
- 전체 층 수 계산
    - `totalLayers = (n + w - 1) / w` : 올림 나눗셈으로 전체 층 수 구하기
- 위층 순회하며 세로줄 상자 찾기
    - `layer + 1`부터 `totalLayers`까지 반복
    - 각 층에서 같은 세로줄에 있는 상자 번호 계산:
        - 홀수 층: `boxNum = upperStart + posInLayer`
        - 짝수 층: `boxNum = upperStart + w - 1 - posInLayer`
    - 해당 상자가 실제 존재하면 count 증가

#### 출력
- 꺼내야 하는 총 상자 개수
    - 자기 자신(1) + 위에 있는 같은 세로줄 상자 개수
### 시간 복잡도
- O(n)
    - 전체 층 수만큼 반복

### 코드
```java  
class Solution {
    public int solution(int n, int w, int num) {
        // num의 층과 위치
        int layer = (num - 1) / w + 1;
        int layerStart = (layer - 1) * w + 1;
        
        int posInLayer;
        if (layer % 2 == 1) {
            posInLayer = num - layerStart;
        } else {
            posInLayer = layerStart + w - 1 - num;
        }
        
        // 전체 층 수
        int totalLayers = (n + w - 1) / w;
        
        // 개수 세기
        int count = 1;  // 자기 자신
        
        // 위의 각 층
        for (int i = layer + 1; i <= totalLayers; i++) {
            int upperStart = (i - 1) * w + 1;
            int upperEnd = Math.min(i * w, n);
            
            // 그 층에서 같은 열에 있는 상자 번호
            int boxNum;
            if (i % 2 == 1) {  // 홀수 층
                boxNum = upperStart + posInLayer;
            } else {  // 짝수 층
                boxNum = upperStart + w - 1 - posInLayer;
            }
            
            // 그 상자가 실제로 존재하면
            if (boxNum >= upperStart && boxNum <= upperEnd) {
                count++;
            }
        }
        
        return count;
    }
}
```

### 알게된점
- 홀수 -> 짝수로 층 이동할 때 위치 번호가 뒤집히는 거를 식으로  (w-3) 가져와야 한다