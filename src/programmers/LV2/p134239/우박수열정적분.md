https://school.programmers.co.kr/learn/courses/30/lessons/134239

### 문제 풀이 날짜
20254-10-24

### 문제 분석 요약
- 콜라츠 추측 -> 우박수열
```
1-1. 입력된 수가 짝수라면 2로 나눕니다.
1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
2.결과로 나온 수가 1보다 크다면 1번 작업을 반복합니다.
```
- 우박수열을 좌표평면 위 꺾은선그래프로 나타낼때
- 초항이 k인 우박수열이 있다면, x = 0일때 y = k이고 다음 우박수는 x = 1에 표시
- x에 대한 어떤 범위 [a, b]가 주어진다면 이 범위에 대한 정적분 결과는 꺾은선 그래프와 x = a, x = b, y = 0 으로 둘러 쌓인 공간의 면적과 같습니다.
- 0 이상의 수 b에 대해 [a, -b]에 대한 정적분 결과는 x = a, x = n - b, y = 0 으로 둘러 쌓인 공간의 면적으로 정의하며, 이때 n은 k가 초항인 우박수열이 1이 될때 까지의 횟수를 의미합니다.
- 우박수의 초항 `k`와, 정적분을 구하는 구간들의 목록 `ranges`가 주어졌을 때 정적분의 결과 목록을 return 하도록 solution을 완성하는 문제

### 제약조건
- 2 ≤`k`≤ 10,000
- 1 ≤ `ranges`의 길이 ≤ 10,000
    - `ranges`의 원소는 [a, b] 형식이며 0 ≤ a < 200, -200 < b ≤ 0 입니다.
- 주어진 모든 입력에 대해 정적분의 결과는 227 을 넘지 않습니다.
- 본 문제는 정답에 실수형이 포함되는 문제입니다. 입출력 예의 소수 부분 `.0`이 코드 실행 버튼 클릭 후 나타나는 결괏값, 기댓값 표시와 다를 수 있습니다.
- 주어진 구간의 시작점이 끝점보다 커서 유효하지 않은 구간이 주어질 수 있으며 이때의 정적분 결과는 -1로 정의
### 알고리즘 설계

문제의 핵심
- 우박수열을 저장해서 인덱스로 접근하게 만든다
- 각 구간[a,b]에 대해
    - 시작점과 끝점을 계산
    - 유효한 구간인지 확인
    - 사다리꼴 면적들을 차례로 계산해 합산

예제로 이해하기
- k =5 일때
- 우박수열 : 5 -> 16 -> 8 -> 4 -> 2 -> 1
- 좌표 (0, 5) (1, 16) (2, 8) (3, 4) (4, 2) (2, 1)
- ranges `[[0,0],[0,-1],[2,-3],[3,-3]]` 가 주어졌을때
    - `[0,0]` 은 `x = a, x = n + b, y = 0`에 따라서 `[0,5]`이고
    - `[0,5]`는 `[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]` 영역의 크기 -> 사다리꼴의 면적을 계산
    - `[0, 1]` : (5 + 16) x 1 / 2 = 10.5
    - `[1, 2]` : (16 + 8) x 1 / 2 = 12.0
    - `[2, 3]` : (8 + 4) x 1 / 2 = 6.0
    - `[3, 4]`: (4 + 2) x 1 / 2 = 3.0
    - `[4, 5]` : (2 + 1) x 1 /2 = 1.5
    - 전체 합 : 33.0

#### 입력
- 우박수의 초항 `k`
- 정적분을 구하는 구간들의 목록 `ranges`

#### 연산
1. 우박수열을 계산해서 저장한다
- 주어진 k에 따라 우박수열의 개수가 달라지기 때문에 ArrayList에 저장
- 우박수열의 초기값 k 리스트에 저장
- 우박수열 계산 (1보다 k가 큰 경우에 반복하도록 while문 사용)
- 1) 1-1. 입력된 수가 짝수라면 2로 나눕니다.
  2) 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
  3) 2.결과로 나온 수가 1보다 크다면 1번 작업을 반복합니다.
- 계산한 우박수열 탐색횟수는 n

2. range배열에 있는 범위 파악해 정적분 계산
   1) ranges의 길이만큼 반복문 수행 (for문)
   - 인덱스의 숫자가 2개로 고정되어 있으니까 두개의 값을 가져온다
     - `int a = ranges[i][0] , int b = ranges[i][1]`
   - 탐색할 범위를 찾아준다 
     - 조건 : `x = a, x = n - b, y = 0`
     - a를 시작점(start)으로 a + n 을 끝점(end)로 선언
     - 시작점 > 끝점인 경우
       - `-1`을 정답 배열에 저장 answer[i]
       - 다음 반복으로 순회
   2) 사다리꼴 크기 계산
   - 범위 내 전체 크기구하는 double 타입 totalArea 변수 선언
   - 시작점에서 끝점까지 반복문 수행
   - 사다리꼴 크기 구하는 공식 (아랫변 + 윗변) * 높이 /2;
   - (우박수열 list index값 + index + 1) * 1.0 / 2; (높이는 1로 고정이 조건에 있음)
   - 구한 값을 area에 저장
   - totalArea += area 저장
   
#### 출력
 -  ranges에서 제시한 각 범위의 크기 answer 배열 

#### 필요한 변수
- 우박수열을 저장할 list `numberSequence`
- 우박수열 탐색횟수 int 타입 변수 n
- 정적분을 저장할 double 타입 배열 `answer`
- ranges 배열에서 구할 범위 int 타입 변수 a, b
- 범위 내 전체 크기구하는 double 타입 totalArea 변수
- 범위 내 탐색하는 double 타입 area 변수 

### 시간 복잡도
- O(N)
  - 우박수열의 길이

### 코드
```java  
import java.util.*;

class Solution {
    public double[] solution(int k, int[][] ranges) {
        double[] answer = new double[ranges.length];
        List<Integer> numberSequence = new ArrayList<>();
        numberSequence.add(k);
        // 우박수열 계산
        while(k > 1) {
            if (k % 2 == 0) {
                k = k / 2;
            } else {  
                k =  k * 3 + 1;
            }
            numberSequence.add(k);
        }
        
        // 지정된 범위 가져오기
        int n = numberSequence.size() - 1;
        for (int i = 0; i < ranges.length; i++){
            int a = ranges[i][0];
            int b = ranges[i][1];
            
            int start = a;
            int end = n + b;
            
            if (start > end) {
                answer[i] = -1.0;
                continue;
            }
            
            // 사다리꼴 구하기
            double totalArea = 0.0;
            for (int j = start; j < end; j++){
                double area = (numberSequence.get(j) + numberSequence.get(j + 1)) * 1.0 /2;
                totalArea += area;
            }
            answer[i] = totalArea;
        }
        
        return answer;
    }
}
```
![p134239](p134239.png)

### 알게된점
- 문제가 길어서 문제 자체를 탐색하는데 시간이 많이 걸렸다. 문제의 주어진 조건을 잘 해석하는게 어려운 알고리즘을 사용하는 것 보다 더 중요하다.