https://school.programmers.co.kr/learn/courses/30/lessons/12913

### 문제 풀이 날짜
2025-10-21

https://school.programmers.co.kr/learn/courses/30/lessons/12913
### 문제 분석 요약
- N행 4열의 땅을 1행부터 밟으면서 내려올때 같은 열을 연속해서 밟지 않고 4칸중 한칸만 밟아서 마지막행까지 내려올 때 얻을 수 있는 점수의 최대값을 반환하는 문제
- -> 나의 언어 : N행에 4열에 있는 숫자를 하나씩 선택해 밟을때 가장 큰 값을 선택한다. 현재 있는 칸의 숫자와 동일한 행은 밟지 않는다

### 제약조건
- 행의 개수 N : 100,000 이하의 자연수
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
- 점수 : 100 이하의 자연수
- 현재 있는 칸의 숫자와 동일한 행은 밟지 않는다
### 알고리즘 설계

#### 변수
- `dp[i][j]` : i번째 행의 j번째 열을 밟았을 때의 최대 점수
- `n` : 땅의 행 개수
- `maxPrev` : 이전 행에서 현재 열이 아닌 다른 열들 중 최대값
- `answer` : 마지막 행에서 얻을 수 있는 최대 점수
#### 입력
- 게임의 땅 이차원 배열 land
#### 연산
- 첫 번째 행을 dp 배열에 초기화(첫번째 행은 비교할 이전 값이 없기 때문)
- 두 번째 행부터 N번째 행까지 반복하면서: (여기서부터는 이전행이 존재함)
    - 현재 열이 아닌 다른 열인 경우에만
    - 각 열 j에 대해 이전 행의 다른 열들 중 최대값을 찾음
    - 현재 반복하는 행열의 값과 이전 행의 최대값을 더한 값을
        - `dp[i][j] = land[i][j] + maxPrev` 계산
- 마지막 행에서 4개 열 중 최대값을 찾아 반환
#### 출력
- 최대값을 가지고 있는 마지막 행의 칸 중에서 4개 열 중 최대값을 찾아 반환
  -`Math.max(answer, dp[n-1][j])`

### 시간 복잡도
- O(N)
    - 행의 개수가 4로 고정되어 있기 때문에 3중반복문이지만 o(n)으로 수렴한다
### 코드
```java  
class Solution {
    int solution(int[][] land) {
        int answer = 0;
        int n = land.length; // land에서 구한 행
        
        int[][] dp = new int[n][4]; // 최대 누적 점수 저장할 배열
        
        for (int col = 0; col < 4; col++) { // 첫번째 행 값 입력
            dp[0][col] = land[0][col];
        }
        
        for (int row = 1; row < n; row++) {  
            for (int col = 0; col < 4; col++) {
                int maxPrev = 0;
                for (int prevCol = 0; prevCol < 4; prevCol++) {
                    if (prevCol != col) {
                        maxPrev = Math.max(maxPrev, dp[row-1][prevCol]);
                    }
                }
                    dp[row][col] = land[row][col] + maxPrev;
            }
        }
            
        for (int col = 0; col < 4; col++) {
            answer = Math.max(answer, dp[n-1][col]);
        }
        return answer;
    }
}
```


### 알게된점
- 처음에 탐색 + 최대라고 해서 bfs를 사용해야 한다고 생각했는데 bfs로 탐색할 경우에 n의 최대가 10만인 것을 고려했을때 경로가 3백만개 정도로 엄청 많이 나온다
- 최적의 해, 이전 값을 활용할 수 있다는 점이 dp로 풀었을때 효과적이라는 것을 알 수 있다