https://school.programmers.co.kr/learn/courses/30/lessons/12913

### 문제 풀이 날짜
2025-10-21

### 문제 분석 요약
- N행 4열의 땅을 1행부터 밟으면서 내려올때 같은 열을 연속해서 밟지 않고 4칸중 한칸만 밟아서 마지막행까지 내려올 때 얻을 수 있는 점수의 최대값을 반환하는 문제

### 제약조건
- 행의 개수 N : 100,000 이하의 자연수
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
- 점수 : 100 이하의 자연수
### 알고리즘 설계

#### 변수
- `dp[i][j]` : i번째 행의 j번째 열을 밟았을 때의 최대 점수
- `n` : 땅의 행 개수
- `maxPrev` : 이전 행에서 현재 열이 아닌 다른 열들 중 최대값
- `answer` : 마지막 행에서 얻을 수 있는 최대 점수
#### 입력
- 게임의 땅 이차원 배열 land
#### 연산
- 첫 번째 행을 dp 배열에 초기화
- 두 번째 행부터 N번째 행까지 반복하면서:
    - 각 열 j에 대해 이전 행의 다른 열들(k≠j) 중 최대값을 찾음
    - `dp[i][j] = land[i][j] + maxPrev` 계산
- 마지막 행에서 4개 열 중 최대값을 찾아 반환
#### 출력
- 마지막 행에서 4개 열 중 최대값을 찾아 반환

### 시간 복잡도
- O(N)
### 코드
```java  
class Solution {
    int solution(int[][] land) {
        int n = land.length;
        
        // dp[i][j] = i번째 행의 j번째 열을 밟았을 때의 최대 점수
        int[][] dp = new int[n][4];
        
        // 첫 번째 행 초기화
        for (int j = 0; j < 4; j++) {
            dp[0][j] = land[0][j];
        }
        
        // 두 번째 행부터 DP 계산
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 4; j++) {
                // 현재 열(j)이 아닌 다른 열들 중에서 최대값 찾기
                int maxPrev = 0;
                for (int k = 0; k < 4; k++) {
                    if (k != j) {
                        maxPrev = Math.max(maxPrev, dp[i-1][k]);
                    }
                }
                dp[i][j] = land[i][j] + maxPrev;
            }
        }
        
        // 마지막 행에서 최대값 찾기
        int answer = 0;
        for (int j = 0; j < 4; j++) {
            answer = Math.max(answer, dp[n-1][j]);
        }
        
        return answer;
    }
}
```


### 알게된점
- 