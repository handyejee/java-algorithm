https://school.programmers.co.kr/learn/courses/30/lessons/154540

### 문제 풀이 날짜
2025-10-17

### 문제 분석 요약
- 지도에 표시된 정보를 보고 각 섬에서 최대 며칠씩 머무를 수 있는지 구하는 문제
- 지도는 1x1크기의 사각형 직사각형 격자이고 각 칸에는 1-9 사이 자연수가 적혀있다
- 지도의 `X`는 바다, 숫자는 무인도
- 상하좌우로 연결되는 땅은 하나의 무인도
- 지도의 각 칸에 적힌 숫자는 식량
- 상,하,좌,우로 연결된 땅 무인도
-

### 제약조건
-  - 지낼 수 있는 무인도가 없으면 -1을 담은 배열 반환
- 3 ≤ maps의 길이 ≤ 100
- 3 ≤ maps[i]의 길이 ≤ 100
- maps[i]는 'X' 또는 1~9 사이의 자연수로 이루어진 문자열
### 알고리즘 설계

#### 변수
- `visited[][]`: 방문 여부를 체크하는 2차원 배열
- `result`: 각 섬의 일수를 저장할 리스트
- `dx[], dy[]`: 상하좌우 이동을 위한 방향 배열
- `rows, cols`: 지도의 행과 열 크기
#### 입력
- 지도를 나타내는 문자열 배열 maps
#### 연산
- 지도의 모든 칸을 순회
- 방문하지 않은 숫자 칸을 발견하면 DFS 시작
- 연결된 모든 칸의 숫자를 합산
- 합산 결과를 result에 추가
- 모든 탐색 완료 후 result를 오름차순 정렬
- result가 비어있으면 [-1] 반환
#### 출력
- 각 섬에서 머무를 수 있는 일수를 오름차순으로 정렬한 배열

### 시간 복잡도
- O(N × M): 지도의 모든 칸을 한 번씩 방문 (N: 행, M: 열)
### 코드
```java  
import java.util.*;

class Solution {
    private static final int[] dx = {-1, 1, 0, 0};
    private static final int[] dy = {0, 0, -1, 1};
    
    private int rows, cols;
    private boolean[][] visited;
    private char[][] map;
    
    public int[] solution(String[] maps) {
        rows = maps.length;
        cols = maps[0].length();
        visited = new boolean[rows][cols];
        map = new char[rows][cols];
        
        for (int i = 0; i < rows; i++) {
            map[i] = maps[i].toCharArray();
        }
        
        List<Integer> result = new ArrayList<>();
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (!visited[i][j] && map[i][j] != 'X') {
                    result.add(dfs(i, j));
                }
            }
        }
        
        if (result.isEmpty()) return new int[]{-1};
        
        Collections.sort(result);
        return result.stream().mapToInt(i -> i).toArray();
    }
    
    private int dfs(int x, int y) {
        visited[x][y] = true;
        int sum = map[x][y] - '0';
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols 
                && !visited[nx][ny] && map[nx][ny] != 'X') {
                sum += dfs(nx, ny);
            }
        }
        
        return sum;
    }
}
```


### 알게된점
- 어떤 경우에 DFS, BFS를 사용해야 할까 ?
- 최단거리를 예로 들었을때 DFS는 모든 경로를 탐색하기 때문에 시간복잡도에서 큰 차이를 보인다. 모든 경로를 확인하는 경우에는 DFS가 적절하지만 최단거리 탐색에는 BFS가 효과적이다
```java 
// BFS
int bfs() {
    Queue<Node> q = new LinkedList<>();
    q.offer(new Node(0, 0, 0));  // x, y, 거리
    
    while (!q.isEmpty()) {
        Node cur = q.poll();
        
        if (도착) return cur.dist;  // 처음 = 최단!
        
        // 4방향 탐색...
    }
}

시간: O(N*M) - 한 번씩만 방문
```

```java
// DFS
int minDist = Integer.MAX_VALUE;

void dfs(int x, int y, int dist) {
    if (도착) {
        minDist = Math.min(minDist, dist);  // 비교 필요
        return;
    }
    
    // 4방향 탐색...
}

시간: O(4^(N*M)) - 모든 경로 탐색
```