https://school.programmers.co.kr/learn/courses/30/lessons/42842

### 문제 풀이 날짜
2025-10-14

### 문제 분석 요약
- 중앙에는 노란색, 테두리에는 갈색으로 칠해진 격자모양 카펫의 개수를 보고 전체 카펫의 가로, 세로 길이를 배열로 반환하는 문제

### 제약조건
-  갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
- 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
- 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.
### 알고리즘 설계

#### 변수
- 격자의 전체 크기 total
- 카펫의 가로 w, 세로 h
- w, h 반환해줄 int 배열 answer
#### 입력
- 갈색 격자의 수 brown
- 노란색 격자의 수 yellow

#### 연산
- 주어진 값은 노란격자와 갈색 격자의 개수
- 노란격자 + 갈색격자 = 전체 격자 개수(`yellow + brown = total`)
    - 전체 격자의 개수 = 가로 x 세로(구하는 값)
- 노란격자  =  (가로  - 2) x (세로 - 2)(`yellow = (w -2) * (h -2)`)
- 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색
  -> 가로, 세로 모두가 최소 3이상이어야지 노란격자가 위치할 수 있다 (`int h =3;`)
- 전체 격자의 개수를 만족하는 경우를 찾는다
- 미지수 w, h를 구하기 위해 h값을 하나씩 확인하면서 w값이 조건에 맞는지 확인하는 부분이 문제를 푸는 포인트.. !

- w,h 를 넣어줄 answer 배열의 크기를 2로 선언 (new int[2])
- h = 3 이고 total에 다다를 때까지 반복문 수행
    - total % h == 0 인경우 (h x w = total을 만족하는 경우)
    - total / h의 몫을 w로 선언한다
    - w >= h 조건을 만족하는 경우
    - `yellow = (w -2) * (h - 2)` 를 만족하면 -> w, h의 크기를 구했으므로
    - `w = answer[0], h = answer[1]` 를 넣어준다
- 배열을 반환
#### 출력
- 가로, 세로가 담긴 배열을 반환한다

### 시간 복잡도
- O(N)
    - total의 크기(brown x yellow) 만큼 반복문 수행 -> O(N)에 수렴
    - 내부 조건문은 상수시간
### 코드
```java  
class Solution {
    public int[] solution(int brown, int yellow) {
        int[] answer = new int[2];
        
        int total = brown + yellow;
        
        for (int h = 3; h < total; h++) {
            if (total % h  == 0) {
                int w = total / h; 
                
                if (w >= h) {
                    if ((w - 2) * (h - 2) == yellow) {
                      answer[0] = w;
                      answer[1] = h;
                    }
                }
            }
        }
        
        return answer;
    }
}
```


### 알게된점
- 문제의 조건을 정리해도 코드로 풀어내는게 어려웠는데, 미지수 여러개가 있을때 주어진 조건을 가지고 한가지 값을 구하고 나머지 값을 구하는 방법으로 생각해야 한다.
- 문제의 조건(중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색) 에서 w, h의 크기가 최소 3이라는 것을 알 수 있는데 문제의 조건을 분석하고 제약조건을 확인하는게 중요하다.
- `int[] answer = new int{}` 는 빈배열