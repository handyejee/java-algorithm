https://school.programmers.co.kr/learn/courses/30/lessons/43165

### 문제 풀이 날짜
2025-12-02

### 문제 분석 요약
-  numbers 배열의 정수에서 순서를 바꾸지 않고 더하거나 빼기만으로 target 을 만족하는 경우의 수를 구하는 문제
### 문제의 핵심
- 배열의 모든 수를 전부 탐색해야 한다 -> DFS
### 제약조건
- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.
### 알고리즘 설계

#### 입력
- `numbers`: 사용할 수 있는 숫자가 담긴 배열
- `target`: 타겟넘버
#### 연산
- DFS 재귀를 사용한다
    - 파라미터 : index(현재위치), currentSum(현재까지의 합)
    - 종료조건 : 배열의 길이와 index가 일치하는 경우 return
        - 현재 재귀 숫자의 합(currentSum)이 target이 일치하는경우 answer++
    - 재귀 호출(종료 조건이 아닌경우) :
        - 현재 숫자를 더하는 경우
        - 현재 숫자를 빼는 경우
#### 출력
- 타겟넘버를 만족시키는 경우의 수 출력
### 시간 복잡도
- O(N^2)
    - `재귀 2번 호출 * N(numbers.length)`
### 코드
```java  
class Solution {
    int answer = 0;
    
    public int solution(int[] numbers, int target) {        
        dfs(numbers, target, 0, 0);
        return answer;
    }
    
    void dfs(int[] numbers, int target, int index, int currentSum) {
        if(index == numbers.length) {
            if(currentSum == target) answer++;
            return;
        }
        
        dfs(numbers, target, index + 1, currentSum + numbers[index]);
        dfs(numbers, target, index + 1, currentSum - numbers[index]);
    }
}
```
![p43165.png](p43165.png)

### 알게된점
- 깊이우선탐색은 N의 크기의 비례해서 시간복잡도의 크기가 커진다
    - 오늘 문제 처럼 이진트리의 경우 dfs() 호출을 2번 해야 하고 이런 경우에는 O(2^N)의 시간복잡도를 가지게 된다.
