https://school.programmers.co.kr/learn/courses/30/lessons/42586

### 문제 풀이 날짜
2025-11-24

### 문제 분석 요약
- 각 기능은 진도가 100%가 되어야 배포 가능
- 앞선 기능이 완료되지 않으면 뒤의 기능도 함께 대기
- 앞선 기능 완료 시 대기 중이던 뒤의 기능들도 함께 배포
- 각 배포마다 몇 개의 기능이 배포되는지 계산

### 문제의 핵심
- 각 기능의 완료까지 필요한 일수를 계산
### 제약조건
- 작업의 개수는 100개 이하
- 작업 진도는 100 미만의 자연수
- 작업 속도는 100 이하의 자연수
- 배포는 하루에 한 번만, 하루의 끝에 이루어짐
### 알고리즘 설계

#### 입력
- `progresses`: 각 기능의 현재 진도 배열
- `speeds`: 각 기능의 일일 개발 속도 배열
#### 연산
- 각 기능의 완료까지 필요한 일수를 계산: `Math.ceil((100 - progress) / speed)`
- 계산된 일수를 Queue에 순서대로 삽입 (offer)
- Queue가 빌 때까지 반복:
    - Queue에서 첫 번째 기능의 완료일을 꺼냄 (poll) → 현재 배포 기준일로 설정
    - 배포 개수 count = 1로 초기화
    - Queue의 맨 앞(peek)을 확인하며 기준일 이하인 기능들을 제거:
        - `peek() <= 기준일`이면 poll()하고 count 증가
        - `peek() > 기준일`이면 반복 종료
    - 현재 배포 그룹의 count를 결과 리스트에 추가
- 모든 배포 그룹 처리 완료
#### 출력
- 각 배포마다 배포되는 기능의 개수를 담은 배열
### 시간 복잡도
- O(N)
    - 각 기능을 Queue에 한번 삽입하고 한번 제거하므로 총 2N번의 연산 수행
### 코드
```java  
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> daysQueue = new ArrayDeque<>();
        List<Integer> answer = new ArrayList<>();
        
        // 1. 각 기능의 완료 일수를 계산하여 Queue에 넣기
        for (int i = 0; i < progresses.length; i++) {
            int days = (int) Math.ceil((100.0 - progresses[i]) / speeds[i]);
            daysQueue.offer(days);
        }
        
        // 2. Queue에서 꺼내면서 배포 그룹 계산
        while (!daysQueue.isEmpty()) {
            int currentDay = daysQueue.poll();  // 현재 배포 기준일
            int count = 1;  // 현재 기능 포함
            
            // 같은 배포 그룹에 포함될 기능들 확인
            while (!daysQueue.isEmpty() && daysQueue.peek() <= currentDay) {
                daysQueue.poll();  // 같은 그룹이면 제거
                count++;
            }
            
            answer.add(count);  // 배포 그룹의 기능 개수 저장
        }
        
        return answer.stream().mapToInt(Integer::intValue).toArray();
    }
}

```

### 알게된점
- 큐 카테고리의 문제라서 큐로만 풀어야 한다고 생각했는데 ArrayList로도 풀수 있는걸 알게되어서 다시 한번 풀어봐야 할것 같다.