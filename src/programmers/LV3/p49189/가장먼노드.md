https://school.programmers.co.kr/learn/courses/30/lessons/49189

### 문제 풀이 날짜
2025-11-25

### 문제 분석 요약
-  1번 노드에서 출발하여 각 노드까지의 최단 거리 계산
- 최단 거리가 가장 긴 노드들의 개수를 구하는 문제

### 문제의 핵심
- BFS(너비 우선 탐색)를 사용하여 최단 거리 계산
### 제약조건
- 노드의 개수 n: 2 ≤ n ≤ 20,000
- 간선의 개수: 1 ≤ edges ≤ 50,000
- 간선은 양방향
- 모든 노드는 연결되어 있음 (연결 그래프)
### 알고리즘 설계

#### 입력
- `n`: 노드의 개수
- `vertex`: 간선 정보를 담은 2차원 배열
#### 연산
- 그래프 구성
    - 인접 리스트 형태로 그래프 생성
    - 양방향 간선이므로 a -> b, b <- a 모두 추가
- BFS로 최단 거리 계산
    - 거리 배열 초기화 (distance[i] = -1, 방문하지 않음을 의미)
    - Queue에 시작 노드(1번) 삽입, distance[1] = 0
    - Queue가 빌 때까지 반복:
        - 현재 노드를 꺼냄 (poll)
        - 현재 노드의 인접 노드들을 확인
        - 방문하지 않은 인접 노드(distance == -1)를 Queue에 추가
        - 인접 노드의 거리 = 현재 노드의 거리 + 1
- 최댓값 찾기 및 카운팅
    - distance 배열에서 최댓값 찾기
    - 최댓값과 같은 거리를 가진 노드의 개수 세기
#### 출력
- 1번 노드로부터 가장 멀리 떨어진 노드의 개수
### 시간 복잡도
- O(V + E)
    - V: 노드의 개수, E: 간선의 개수
    - 그래프 구성: O(E)
    - BFS 탐색: O(V + E) - 각 노드를 한 번씩 방문, 각 간선을 한 번씩 확인
### 코드
```java  
import java.util.*;

class Solution {
    public int solution(int n, int[][] vertex) {
        // 1. 그래프 구성 (인접 리스트)
        ArrayList<Integer>[] graph = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        
        for (int[] edge : vertex) {
            int a = edge[0];
            int b = edge[1];
            graph[a].add(b);
            graph[b].add(a); // 양방향 간선
        }
        
        // 2. BFS를 위한 초기화
        int[] distance = new int[n + 1];
        Arrays.fill(distance, -1); // -1: 미방문
        
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1); // 1번 노드에서 시작
        distance[1] = 0;
        
        // 3. BFS 수행
        while (!queue.isEmpty()) {
            int current = queue.poll();
            
            for (int next : graph[current]) {
                if (distance[next] == -1) { // 방문하지 않은 노드
                    distance[next] = distance[current] + 1;
                    queue.offer(next);
                }
            }
        }
        
        // 4. 가장 먼 거리 찾기
        int maxDistance = 0;
        for (int i = 1; i <= n; i++) {
            maxDistance = Math.max(maxDistance, distance[i]);
        }
        
        // 5. 가장 먼 거리를 가진 노드의 개수 세기
        int count = 0;
        for (int i = 1; i <= n; i++) {
            if (distance[i] == maxDistance) {
                count++;
            }
        }
        
        return count;
    }
}
```

### 알게된점
- 