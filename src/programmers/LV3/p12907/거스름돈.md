https://school.programmers.co.kr/learn/courses/30/lessons/12907

### 문제 풀이 날짜
2025-12-05

### 문제 분석 요약
- money에 있는 돈으로  거스름돈n을 만들 수 있는 경우의 수를 구하는 문제
### 문제의 핵심
- money에 있는 돈은 무한으로 빼서 사용할 수 있고 n을 만드는 경우의 수를 구한다
- money에 있는 원소를 순회하면서 나머지를 0으로 만드는 경우의 수를 찾아야 한다
- `money[i] % n == 0`
### 제약조건
- n은 100,000 이하의 자연수입니다.
- 화폐 단위는 100종류 이하입니다.
- 모든 화폐는 무한하게 있다고 가정합니다.
- 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.
### 알고리즘 설계

#### 입력
- `n`: 거슬러 줘야 하는 금액
- `Money`: Finn이 현재 보유하고 있는 돈의 종류
#### 연산
- dp 배열을 초기화 한다
    - 배열의 크기는 n + 1
    - dp[0] = 1
        - 0개의 동전을 사용해서 만들 수 있는 방법은 0개만 사용하는 거니까 1개
- money 배열의 모든 동전을 순회한다
    - 배열의 원소를 coin으로 지정하고 현재의 원소부터 n까지의 숫자를 순회하면서
    - 현재 동전을 사용하는 방법과 나머지 동전을 사용하는 방법을 누적합 해준다
        -  1원짜리 동전이 있을 때
        - 1원 동전을 0개 ~ n개 사용해서 "i원"을 만드는 수
    - 점화식 `dp[i] += dp[i - coin]`
#### 출력
- n을 만들 수 있는 경우의 수 출력
### 시간 복잡도
- O(m × n)
    - money를 순회하고 (m번)
    - 각 동전마다 n까지 순회 (n번)
### 코드
```java  
class Solution {
    public int solution(int n, int[] money) {
        // dp배열 초기화
        int[] dp = new int[n + 1];
        dp[0] = 1;
        
        // 연산
        for (int coin : money) {
	        for (int i = coin; i <= n; i++) {
		        dp[i] += dp[i - coin];
	        }
        }
        // 출력
        return dp[n]; 
    }
}
```
![p12907.png](p12907.png)

### 알게된점
- 점화식은 규칙이 있지만 이 문제에서 어떻게 점화식을 활용할지가 아직 생각이 잘 안난다.
