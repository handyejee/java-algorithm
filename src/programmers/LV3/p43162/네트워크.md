https://school.programmers.co.kr/learn/courses/30/lessons/43162?language=java

### 문제 풀이 날짜
2025-10-02

### 문제 분석 요약
- 컴퓨터의 개수 n, 연결 정보가 담긴 배열 computers가 매개변수로 주어질 때 네트워크의 개수를 return 하는 문제

### 제약조건
-  컴퓨터의 개수 n은 1 이상 200 이하인 자연수
- 각 컴퓨터는 0부터 `n-1`인 정수로 표현합니다.
- i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
- computer[i][i]는 항상 1입니다
### 알고리즘 설계

#### 변수
- visited[]: 방문 체크 배열 (boolean, 크기 n)
- answer: 네트워크 개수 (int, 초기값 0)
#### 입력
- 컴퓨터 개수 n
- `computers[][]`: 연결 정보 (2차원 int 배열)

#### 연산
- visited 배열을 false로 초기화
- networkCount 변수 0으로 초기화
- 0번부터 n-1번까지 모든 컴퓨터 순회
    - 방문하지 않은 컴퓨터라면  `visited[i] == false`
        - DFS 탐색
        - 탐색이 끝나면 count 개수를 1 올리기
    - 모든 컴퓨터 확인이 끝나면 카운트 반환

- DFS 함수
    - 파라미터로 받는 것:
        - `node`: 현재 탐색할 컴퓨터 번호 (int)
        - `computers[][]`: 연결 정보 배열 (2차원 int 배열)
        - `n`: 전체 컴퓨터 개수 (int)
    - 방문한 컴퓨터 visited = true로 표시
    - 0번 컴퓨터부터 마지막 컴퓨터까지 하나씩 확인
        - 현재 컴퓨터와 연결되어 있는지 확인 (computers[node][i] == 1)
        - 아직 방문하지 않았는지 확인 (visited[i] == false)
        - 두 조건을 모두 만족하면 그 컴퓨터로 DFS 재귀 호출
    - for문이 끝나면 자동 종료 (base case 없음)
#### 출력
- 네트워크 개수 (answer)

### 시간 복잡도
- O(N^2)
    - 외부 for문: O(n) - 모든 컴퓨터 순회
    - DFS 내부 for문: O(n) - 각 컴퓨터마다 연결 확인
    - 총 최악의 경우: n개 컴퓨터 × n번 확인 = n²
### 코드
```java  
class Solution {
    static boolean[] visited;  // 방문 체크 배열만 클래스 변수
    
    public int solution(int n, int[][] computers) {
        int answer = 0;
        visited = new boolean[n];  // 방문 배열 초기화
        
        // 모든 컴퓨터를 순회
        for (int i = 0; i < n; i++) {
            // 아직 방문하지 않은 컴퓨터면
            if (visited[i] == false) {
                dfs(i, computers, n);  // 탐색 시작 (computers와 n을 명시적으로 전달)
                answer++;  // 네트워크 1개 발견
            }
        }
        
        return answer;
    }
    
    // DFS 함수: node번 컴퓨터에서 연결된 모든 컴퓨터 방문
    static void dfs(int node, int[][] computers, int n) {
        visited[node] = true;  // 현재 컴퓨터 방문 처리
        
        // 모든 컴퓨터 확인
        for (int i = 0; i < n; i++) {
            // node와 i가 연결되어 있고 && i를 아직 방문 안했으면
            if (computers[node][i] == 1 && visited[i] == false) {
                dfs(i, computers, n);  // i번 컴퓨터로 이동해서 탐색
            }
        }
    }
}
```


### 알게된점
- 같은 문제를 여러번 풀어서 dfs 문제를 이해해보도록 하기