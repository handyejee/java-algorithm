https://school.programmers.co.kr/learn/courses/30/lessons/42892

### 문제 풀이 날짜
2025-11-18

### 문제 분석 요약
- 2차원 좌표로 주어진 노드를 이진 탐색 트리로 만드는 문제
- 구성된 트리를 전위순회와 후위 순회 한 결과 반환

### 제약조건
- nodeinfo 길이: 1 ~ 10,000
- 좌표 값: 0 ~ 100,000
- 트리 깊이: 최대 1,000
- 모든 노드의 x값은 서로 다름
### 알고리즘 설계

#### 입력
- `nodeinfo`: 각 노드의 [x좌표, y좌표] 정보 (1번 노드부터 순서대로)
#### 연산
- 노드 정보에 번호 부여 (1부터 N까지)
- y좌표 내림차순, x좌표 오름차순으로 정렬
- 정렬된 순서대로 트리에 삽입 (BST 규칙)
- 전위 순회 및 후위 순회 수행

#### 출력
- `result[0]`: 전위 순회 결과
- `result[1]`: 후위 순회 결과
### 시간 복잡도
- O(N log N):
  - 

### 코드
```java  
import java.util.*;

class Solution {
    // 노드 클래스 정의
    static class Node {
        int num;      // 노드 번호 (1~N)
        int x, y;     // 좌표
        Node left, right;  // 자식 노드
        
        Node(int num, int x, int y) {
            this.num = num;
            this.x = x;
            this.y = y;
        }
    }
    
    // 전위 순회 결과를 저장할 리스트
    List<Integer> preorderList = new ArrayList<>();
    // 후위 순회 결과를 저장할 리스트
    List<Integer> postorderList = new ArrayList<>();
    
    public int[][] solution(int[][] nodeinfo) {
        int n = nodeinfo.length;
        
        // 1. 노드 번호와 좌표 정보를 함께 저장
        List<Node> nodes = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            nodes.add(new Node(i + 1, nodeinfo[i][0], nodeinfo[i][1]));
        }
        
        // 2. y좌표 내림차순, 같으면 x좌표 오름차순으로 정렬
        // y가 클수록 상위 레벨이므로 먼저 처리
        Collections.sort(nodes, (a, b) -> {
            if (a.y != b.y) return b.y - a.y;  // y 내림차순
            return a.x - b.x;  // x 오름차순
        });
        
        // 3. 트리 구성 (첫 번째 노드가 루트)
        Node root = nodes.get(0);
        for (int i = 1; i < n; i++) {
            insertNode(root, nodes.get(i));
        }
        
        // 4. 트리 순회
        preorder(root);
        postorder(root);
        
        // 5. 결과 반환
        int[][] result = new int[2][];
        result[0] = preorderList.stream().mapToInt(i -> i).toArray();
        result[1] = postorderList.stream().mapToInt(i -> i).toArray();
        
        return result;
    }
    
    // BST 규칙에 따라 노드 삽입
    private void insertNode(Node parent, Node child) {
        // 자식의 x좌표가 부모보다 작으면 왼쪽 서브트리
        if (child.x < parent.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        }
        // 자식의 x좌표가 부모보다 크면 오른쪽 서브트리
        else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    // 전위 순회: 부모 → 왼쪽 → 오른쪽
    private void preorder(Node node) {
        if (node == null) return;
        
        preorderList.add(node.num);  // 부모 방문
        preorder(node.left);          // 왼쪽 서브트리
        preorder(node.right);         // 오른쪽 서브트리
    }
    
    // 후위 순회: 왼쪽 → 오른쪽 → 부모
    private void postorder(Node node) {
        if (node == null) return;
        
        postorder(node.left);         // 왼쪽 서브트리
        postorder(node.right);        // 오른쪽 서브트리
        postorderList.add(node.num);  // 부모 방문
    }
}
```

### 알게된점
- 
