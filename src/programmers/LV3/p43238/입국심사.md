https://school.programmers.co.kr/learn/courses/30/lessons/43238

### 문제 풀이 날짜
2025-12-05

### 문제 분석 요약
- n명의 사람이 입국심사를 받을 때 모든 사람이 심사를 완료하는 시간을 구하는 문제
### 문제의 핵심
- 입국 심사를 기다리는 사람, 심사 걸리는 시간의 최대값이 엄청 커질 수 있어서 이진탐색을 사용해야한다
### 제약조건
- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.
### 알고리즘 설계

#### 입력
- `n`: 입국심사를 기다리는 사람 수
- `Money`: Finn이 현재 보유하고 있는 돈의 종류
#### 연산
- 이진 탐색 범위 설정
    - `left = 1`: 최소 시간 (1분)
    - `right = n * max(times)`: 최대 시간 (가장 느린 심사대에서 모든 사람을 처리)
- 이진 탐색 수행
    - `mid` 시간 동안 심사 가능한 총 인원 계산
    - 각 심사대에서 `mid / times[i]`명 심사 가능
    - 총 심사 가능 인원 ≥ n이면 → 시간을 줄여봄 (`right = mid - 1`)
    - 총 심사 가능 인원 < n이면 → 시간을 늘림 (`left = mid + 1`)
- 최솟값 갱신
    - 조건을 만족할 때마다 `answer`를 갱신
#### 출력
- 모든 사람이 심사를 받는데 걸리는 최소 시간
### 시간 복잡도
- O(T × log R)
    - times 배열의 크기 x 시간 범위(right - left)
### 코드
```java  
class Solution {
    public long solution(int n, int[] times) {
        long answer = Long.MAX_VALUE;
        
        // 이진 탐색 범위 설정
        long left = 1;
        long right = (long) n * findMax(times);
        
        while (left <= right) {
            long mid = (left + right) / 2;
            
            // mid 시간 동안 심사 가능한 총 인원 계산
            long totalPeople = 0;
            for (int time : times) {
                totalPeople += mid / time;
                // 오버플로우 방지
                if (totalPeople >= n) break;
            }
            
            if (totalPeople >= n) {
                // n명 이상 심사 가능 → 시간을 줄여봄
                answer = Math.min(answer, mid);
                right = mid - 1;
            } else {
                // n명 미만 심사 가능 → 시간을 늘림
                left = mid + 1;
            }
        }
        
        return answer;
    }
    
    // times 배열에서 최댓값 찾기
    private int findMax(int[] times) {
        int max = times[0];
        for (int time : times) {
            if (time > max) max = time;
        }
        return max;
    }
}
```

### 알게된점
- 
