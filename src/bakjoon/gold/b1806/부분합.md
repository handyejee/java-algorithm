https://www.acmicpc.net/problem/1806

### 문제 풀이 날짜
2025-11-03

### 문제 분석 요약
- 10000 이하 길이 N짜리 수열
- 연속된 수의 부분합이 S 이상 되는 것 중 가장 짧은 길이

### 제약조건
- S를 만족시키는 수열의 합이 없으면 0 출력
### 알고리즘 설계

문제의 핵심
- 브루트포스로 모든 조합을 하면 시간초과가 된다
- 투포인터로 풀어야 한다
    - 시작점, 끝점 두개를 움직이면서 찾기
    - 합이 작으면 끝점을 오른쪽으로 추가
    - 합이 크거나 같으면 시작점을 오른쪽으로 줄이기

- 예시
```text
수열: [5, 1, 3, 5, 10, 7, 4, 9, 2, 8] 
목표: 합 >= 15

start=0, end=0, 합=5 → 15 미만 → end++
start=0, end=1, 합=6 → 15 미만 → end++
start=0, end=2, 합=9 → 15 미만 → end++
start=0, end=3, 합=14 → 15 미만 → end++
start=0, end=4, 합=24 → 15 이상! → 길이 5 기록, start++
```

#### 변수
- 수열의 길이 N
- 만족시켜야 하는 부분합 S
- 수열 담을 배열 numberArray
- 탐색할 변수 start,end
- 현재 합과 비교할 변수 currentSum
- 최솟값 minLength
-
#### 입력
- 첫째줄 : 수열의 길이 N (10 ≤ N < 100,000), 구하고자 하는 부분합 S (0 < S ≤ 100,000,000)
- 둘째줄 : numberArray를 입력 받으면서 수열의 값 넣어준다
#### 연산
- while 문으로 순회
  - 누적합이 S 이상이면
  - 최소길이를 현재 값과 end - start 뺀 값과 비교
  - 시작점++

  - 누적합이 S 미만이면
  - 수열배열의 end 인덱스의 값에 현재 누적합을 누적해준다
  - end++ 로 추가 탐색한다

#### 출력
- 최대값이 조건 만족하는 구간이 없을 경우 0 출력
- 그 외의 경우 최소길이 출력
### 시간 복잡도
- O(N)
    -  start와 end를 각각 한 번씩만 움직임
    - start: 0 -> N으로 최대 N번
    - end: 0 ->N으로 최대 N번

### 코드
```java  
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // 입력
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int S = Integer.parseInt(st.nextToken());

        int[] numberArray = new int[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            numberArray[i] = Integer.parseInt(st.nextToken());
        }

        // 연산
        int start = 0;
        int end = 0;
        int currentSum = 0;
        int minLength = Integer.MAX_VALUE;

        while (true) {
            // 합이 S 이상이면 -> 시작점 이동 (구간 줄이기)
            if (currentSum >= S) {
                minLength = Math.min(minLength, end - start);
                currentSum -= numberArray[start];
                start++;
            }
            // 합이 S 미만이면 -> 끝점 이동 (구간 늘리기)
            else if (end < N) {
                currentSum += numberArray[end];
                end++;
            }

            else {
                break;
            }
        }
        // 출력
        if (minLength == Integer.MAX_VALUE) {
            System.out.println(0);
        } else {
            System.out.println(minLength);
        }
    }
}

```
![b1806](./b1806.png)
### 알게된점
- 누적합에서는 투포인터를 사용한다
    - 연속된 부분 수열
    - 합/ 곱이 특정 값
    - 두 개의 포인터로 범위 조절