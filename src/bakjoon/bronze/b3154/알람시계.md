https://www.acmicpc.net/problem/4435

### 문제 풀이 날짜
2025-09-24

### 문제 분석 요약
- 알람시계를 설정할 때 4자리 숫자(HHMM)를 입력해야 함
- 잘못 입력해도 시간은 24로 나눈 나머지, 분은 60으로 나눈 나머지로 표시됨
- 키보드에서 키 간 이동 비용은 맨하탄 거리(|xa-xb|+|ya-yb|)
- 목표 시각을 만들 수 있는 입력 중 총 이동 비용이 최소인 것을 찾기
- 답이 여러 개면 가장 빠른 시각 출력

### 알고리즘 설계

#### 변수
- 입력받은 시간T, 분 M
- 출력해줄 시간과 분 : resultH, resultM
- minEffort : 최소의 노력으로 키보드 이동한 값(`Integer.MAX_VALUE`로 선언해서 최소 값 갱신하도록)
- effort : 키보드 이동한 값
- keyArr : 숫자 키의 좌표를 저장한 배열
  - n번 인덱스 : 숫자 n의 좌표로 매칭

#### 입력
- `:`를 기준으로 시간 T와 분 M을 각각 입력받는다

#### 연산
- 주어진 시간을 만족하는 모든 경우를 찾기 위해 시간(00-99)와 분(00-99)으로 이중 반복문을 순회
  - 입력된 시간을 24로 나눈 나머지 혹은 입력된 분을 60으로 나눈 나머지가 목표와 같지 않으면 다음 반복으로 continue
  - 입력받은 시와 분을 만족하는 경우
    - 이동거리를 구한다
    - 이동거리가 현재의 최소이동(minEffort)보다 작으면 더 적은 이동거리이므로 minEffort를 갱신한다.
    - 최소 시간h와 최소 분m을 갱신한다
- Stringbuilder을 사용해 최소 시간 h와 최소 분m을 `00:00`출력형태로 만들어준다
  -  h가 10보다 작은 경우 h 앞에 '0'을 붙여준다.
  - m이 10보다 작은 경우 m 앞에 ': 0'을 붙여준다. 10보다 큰 경우에는 `:`와 m을 붙여준다
- 거리를 구하는 함수
  - (|xa-xb|+|ya-yb|) 를 코드로 표현
  - calc(a, b) = |a의 행 - b의 행| + |a의 열 - b의 열|
#### 출력
- StringBuilder로 붙여준 시:분을 출력한다

### 시간 복잡도
- O(10000) = O(1)
  - h 100 x m 100으로 10000이 정해져있다
  - 가능한 모든 4자리 조합(0000~9999) 확인
### 코드
```java  
import java.io.*;
import java.util.*;

public class Main {
    static int[][] keyArr = {
            {3, 1}, {0, 0}, {0, 1}, {0, 2}, {1, 0},
            {1, 1}, {1, 2}, {2, 0}, {2, 1}, {2, 2}
    };
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        
        StringTokenizer st = new StringTokenizer(br.readLine(), ":");
        int T = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        
        int minEffort = Integer.MAX_VALUE;
        int resultH = 0;
        int resultM = 0;
        
        for (int h = 0; h < 100; h++) {
            for (int m = 0; m < 100; m++) {
                if (h % 24 != T || m % 60 != M) {
                    continue;
                }
                
                int effort = calc(h / 10, h % 10) + calc(h % 10, m / 10) + calc(m / 10, m % 10);
                
                if (effort < minEffort) {
                    minEffort = effort;
                    resultH = h;
                    resultM = m;
                }
            }
        }
        
        sb.append(resultH < 10 ? "0" : "").append(resultH)
          .append(resultM < 10 ? ":0" : ":").append(resultM);
        
        System.out.println(sb);
    }
    
    private static int calc(int a, int b) {
        return Math.abs(keyArr[a][0] - keyArr[b][0]) + Math.abs(keyArr[a][1] - keyArr[b][1]);
    }
}
```
![b3154](./b3154.png)

### 느낀점 or 기억할 정보
- 문제를 처음 봤을때는 과정이 많아서 복잡해서 이해하는데 시간이 오래걸렸다
- 모듈로 연산(나눗셈의 나머지를 구하는 연산)을 활용해서 부루트 포스로 푸는 문제
