https://www.acmicpc.net/problem/19532

### 문제 풀이 날짜
2025-09-15

### 문제 분석 요약
- ax + by = c, dx + ey = f 형태의 2원 1차 연립방정식이 주어진다.
- 연립방정식을 풀어 x와 y의 값을 구해 공백으로 분리해 출력한다.

제약조건
- a, b, c, d, e, f는 정수이며, -999 이상 999 이하이다.
- 해 (x, y)가 유일하게 존재하고, x와 y는 각각 -999 이상 999 이하의 정수이다.
### 알고리즘 설계

#### 입력
- 정수 a, b, c, d, e, f를 순서대로 입력받는다
#### 연산
- 완전탐색으로 -999 에서 999까지 식을 만족하는 값을 찾는다

#### 출력
- x와 y를 공백으로 분리해 출력한다


### 시간 복잡도
- O(1)
- 연립방정식 해를 구하는 과정이 모두 상수 시간 연산이므로 시간복잡도는 O(1)이다.

### 코드
```java  
import java.io.*;
import java.util.StringTokenizer;

public class Main {
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

    StringTokenizer st = new StringTokenizer(br.readLine());
    br.close();


    int a = Integer.parseInt(st.nextToken());
    int b = Integer.parseInt(st.nextToken());
    int c = Integer.parseInt(st.nextToken());

    int d = Integer.parseInt(st.nextToken());
    int e = Integer.parseInt(st.nextToken());
    int f = Integer.parseInt(st.nextToken());
    
    for(int i = -999; i <= 999; i++) {
      for(int j = -999; j <= 999; j++) {
        if(a*i + b*j  == c){ 
          if(d*i + e*j  == f) { 
            bw.write(i + " " + j + "\n");
            break;
          }
        }
      }
    }
    bw.flush();
    bw.close();

  }
}
```

### 느낀점 or 기억할 정보
- 크레머의 법칙을 풀면 더 효율적으로 풀수 있다고 하는데, 법칙을 찾다보면 문제를 더 풀기가 어려운것 같아서 완전탐색으로 가능하다면 먼저 풀어볼것.