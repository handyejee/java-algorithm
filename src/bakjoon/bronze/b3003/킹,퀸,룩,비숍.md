https://www.acmicpc.net/problem/3003

### 문제 풀이 날짜
2025-09-22

### 문제 분석 요약
- 흰색 체스 피스 개수를 보고 세트를 만들 수 있는 개수 구하는 문제

### 알고리즘 설계

#### 변수
- 체스 피스의 각 개수를 저장한 배열 originalPieces
- 입력받은 체스 피스를 저장할 정수형 배열 inputPieces
- 계산한 체스 개수를 저장할 정수형 배열 answers

#### 입력
- 킹, 퀸, 룩, 비숍, 나이트 폰을 입력받고 배열에 저장한다

#### 연산
- originalPieces의 각 피스 개수를 기준으로
    -  `구하는 값 = 기준 체스 개수 - 현재 입력 피스 개수`
- 반복문 안에서 구하는 값을 answer[i] 로 입력받는다
- answer 배열을 순회하면서 값을 출력해준다
### 시간 복잡도
- O(N)
### 코드
```java  
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int[] originalPieces = {1, 1, 2, 2, 2, 8};
        int[] input = new int[6];
        int[] answer = new int[6];
        
        for (int i = 0; i < 6; i++) {
	        input[i] = Integer.parseInt(st.nextToken());
		    answer[i]  = originalPieces[i] - input[i];
		
			System.out.print(answer[i] + " ");
        }
    }
}
```
![b3303.png](b3303.png)

### 느낀점 or 기억할 정보
- `구하는 값 = 기준 체스 개수 - 현재 입력 피스 개수` 라는 걸 알게되면 한줄로 바로 문제를 풀 수 있다
- 처음에 틀렸던 이유는 조건문으로 기준 체스 말과 입력받은 체스 말을 비교해서 증감식을 사용해서 풀려고 했는데, 그렇게 되면 증감한 수가 일치하는지를 또다시 확인해야해 불필요한 연산을 여러번 하게 된다.
- 배열의 크기가 6개로 정해져 있기 때문에 입력 + 연산 + 출력을 하나의 반복문에서 할 수 있다.